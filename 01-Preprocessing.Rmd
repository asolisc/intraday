---
title: "Realized Higher Moment Measures"
description: |
  Part 1: Exploratory Data Analysis & Data Preprocessing
author:
  - name: Alexis Solis Cancino
    url: alexis.solisc@gmail.com
    affiliation: ITAM
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc: true
    toc_float: true
    code_folding: true
    theme: "resources/theme.css"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

# --- set chunk options ---
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo = FALSE
)


# --- Load libraries ---
library(tidyverse)   # core-data-science
library(janitor)     # quick data cleansing
library(arrow)       # for columnar super-fast manipulation
library(lubridate)   # working with dates
library(hms)         # working with times
library(here)        # path management
# library(readxl)


# --- Modeling Time Series ---
library(timetk)


# --- Source ggplot2 themes ---
source(here("resources/ggplot2_themes.R"))
```

## 1. Introduction & Importing Data

We'll work with intraday data for the *S&P/BMV IPC Equity Index*. The data consists of `n = 2,133,890` observations and `k = 23` variables. The time-series is composed of prices and trades per minute, spanning from the beginning of 1996 through the first half of 2018.

The first step is, of course, importing the data:

```{r, echo = T}
# Read the parquet file that contains raw data
ipc_intraday <- read_parquet(file = here("data-raw/raw_MEXICO_IPC.parquet"))
```

First thing we do is take a look at the columns and data types that we have:

```{r}
ipc_intraday %>% glimpse()
```

So we have `boolean`, `character`, `numeric` and `time` types of columns. We also note that the names are not very friendly to work with. We fix that by creating a _string_ vector and using that to replace the names in our data. The new names are:

```{r}
# Create vector with new column names
column_names <- c("ticker","raw_date","raw_time","type",
                  "open","high","low","last","volume",
                  "average_price","vwap","no_trades",
                  "correction_qualifiers","open_bid",
                  "high_bid","low_bid","close_bid",
                  "no_bids","open_ask","high_ask","low_ask",
                  "close_ask","no_ask")

# Rename the columns
ipc_intraday <- ipc_intraday %>% set_names(column_names)

# Print names
ipc_intraday %>% names()
```

### Missing values

There seem to be many missing values in the data, so let's count them! We do this per column:

```{r}
map_df(ipc_intraday, ~ sum(is.na(.x))) %>% glimpse()
```

We see that there are 10 columns that have all values as `NA`, therefore we can remove all of these variables. The variables to remove are:

```{r}
# Get which columns have all values as NAs.
columns_to_remove <- map_df(ipc_intraday, ~ sum(is.na(.))) %>%
  pivot_longer(cols = everything(), 
               names_to = "variable", 
               values_to = "no_missing") %>% 
  filter(no_missing > 0) %>%
  pull(variable)

# Print the selected columns.
columns_to_remove
```

Thus, our data is now leaner, and it includes the following variables:

```{r}
# Get a new dataset without the selected columns
ipc_intraday <- ipc_intraday %>% select(-all_of(columns_to_remove))

# Print names
ipc_intraday %>% names()
```

# 2. Feature Engineering & Data Wrangling

We then carry on with the analysis by creating some new variables (a.k.a. *Feature Engineering*) and manipulating the data. The first manipulations we do are the following:

1.  First, a `tidy_date` variable is created, where the date is parsed according to the *ISO 8601* standard that states that dates should be expressed in the `YYYY-MM-DD` format. In consequence, the `raw_date` column is dropped and is replaced by the newly created `tidy_date` variable.

2.  The `raw_time` column is replaced for the `tidy_time` variable, which parses the time correctly.

3.  The `no_bids`, `no_ask`, `average_price`, `ticker`, `type`, `open`, `high`, and `low` columns are removed because (we think) they are of no use for the analysis.

4.  We rename the `last` variable as `last_price`.

```{r}
ipc_intraday <- ipc_intraday %>% 
  
  # Create time variables: tidy_date, tidy_time, tidy_dttm
  mutate(tidy_date = lubridate::ymd(raw_date),
         tidy_time = hms::as_hms(raw_time)
         ) %>%
  
  # Remove some columns
  select(-c(raw_date, raw_time, ticker, type, open, high, low, no_bids, no_ask, average_price)) %>% 
  
  # Get newly created variable to the beginning of tibble
  relocate(starts_with("tidy"), .before = 1) %>% 
  
  # Rename "last" variable
  rename(last_price = last)

# Print the new dataset
ipc_intraday
```


## 2.1 Exploring the time window for prices

Now, let's explore both the `tidy_date` and `tidy_time` variables. First, it's useful to see how many unique dates (i.e. the number of trading-days) are present in the data.

```{r}
n_days <- ipc_intraday %>% 
  distinct(tidy_date) %>% 
  nrow()

# Print the number of days
n_days %>% format(big.mark = ",")
```

So we have `r n_days %>% format(big.mark = ",")` different trading-days.

Now, regarding the `tidy_time` variable, the data shows that we have prices from **05:32 a.m.** all the way through **08:22 p.m.**

```{r}
earliest_times <- ipc_intraday %>% 
  select(tidy_time) %>% 
  unique() %>% 
  arrange(tidy_time) %>% 
  head() %>% 
  pull()

latest_times <- ipc_intraday %>% 
  select(tidy_time) %>% 
  unique() %>% 
  arrange(desc(tidy_time)) %>% 
  head() %>% 
  pull()

tibble(
  earliest = earliest_times,
  latest = latest_times
)
```

We can also visualize how many datapoints we have, per hour.

```{r, layout="l-body-outset", fig.width=8, fig.asp=0.618}
ipc_intraday %>% 
  mutate(tidy_hour = as.factor(hour(tidy_time))) %>% 
  count(tidy_hour, sort = T, name = "trades_per_hour") %>% 
  # mutate(tidy_hour = fct_reorder(tidy_hour, .x = trades_per_hour, .desc = T)) %>%
  ggplot(aes(tidy_hour, trades_per_hour)) +
  geom_col(aes(fill = between(x = as.numeric(tidy_hour), 
                              left = 5, 
                              right = 10)),
           show.legend = F) +
  scale_fill_manual(values = amazing_colors[c(2,8)]) +
  scale_y_continuous(labels = scales::number_format(big.mark = ",")) +
  labs(
    title = "No. Prices per Hour in the Sample",
    x = "Hour",
    y = NULL
  )
```

From the plot above, we see that most of the prices lie between 8:00AM - 3:00PM. It's interesting that the hours `8` and `15` have fewer datapoints. We can further inspect each one to see the hour-minute components of those trades.

```{r, layout="l-body-outset", fig.width=8, fig.asp=0.618}
ipc_intraday %>% 
  mutate(tidy_hour = as.factor(hour(tidy_time)),
         tidy_minute = minute(tidy_time)) %>%
  filter(tidy_hour == 8) %>% 
  count(tidy_minute, sort = T, name = "trades_per_minute") %>% 
  ggplot(aes(tidy_minute, trades_per_minute)) +
  geom_col(aes(fill = tidy_minute < 30),
           show.legend = F) +
  scale_fill_manual(values = amazing_colors[c(8,2)]) +
  scale_x_continuous(breaks = seq(0, 60, 5)) +
  scale_y_continuous(
    labels = scales::number_format(big.mark = ","),
    breaks = seq(0, 5000, length.out = 11)
    ) +
  labs(
    title = "Number of Trades per Minute from 8:00AM-8:59AM",
    x = "Minute",
    y = NULL
  )
```

As expected, the second half-hour is the most active (that is, the period from 8:30AM - 8:59AM).

Now, let's do the same for the `15` hour-mark:

```{r, layout="l-body-outset", fig.width=8, fig.asp=0.618}
ipc_intraday %>% 
  mutate(tidy_hour = as.factor(hour(tidy_time)),
         tidy_minute = minute(tidy_time)) %>%
  filter(tidy_hour == 15) %>% 
  count(tidy_minute, sort = T, name = "trades_per_minute") %>% 
  ggplot(aes(tidy_minute, trades_per_minute)) +
  geom_col(aes(fill = trades_per_minute > 2500),
           show.legend = F) +
  scale_fill_manual(values = amazing_colors[c(2,8)]) +
  scale_x_continuous(breaks = seq(0, 60, 5)) +
  scale_y_continuous(labels = scales::number_format(big.mark = ",")) +
    labs(
    title = "Number of Trades per Minute from 3:00PM-3:59PM",
    x = "Minute",
    y = NULL
  )
```

Here, the time with most trades is 3:00PM exactly. That's what we need because we'll ignore the rest of the trades. Following *Liu, Patton, Sheppard (2013)*, we'll discard any prices that were quoted outside normal business hours. Hence, we want prices that lie between `08:30` and `15:00`.

To achieve this, we'll introduce the concept of a *time series index*.