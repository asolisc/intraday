---
title: "Realized Higher Moment Measures"
description: |
  Part 2: Exploring Realized Higher Moment Measures on the S&P/BMV IPC Index
author:
  - name: Alexis Solis Cancino
    affiliation: ITAM
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc: true
    toc_depth: 2
    css: "resources/theme.css"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  
  # Places figures on their own pages
  fig.pos = 'p',
  
  # Figure resolution and size
  out.width = '100%',
  dpi = 400,
  
  # Latex figure environment
  fig.env = "figure"
)


# --- Load the libraries! ---

# Data Wrangling
library(tidyverse)
library(lubridate)
library(skimr)
library(glue)

# Time Series
library(timetk)
library(tidyquant)
# library(hms)
# library(modeltime)
# library(tidymodels)

# Visualization
# library(ggthemes)
library(scales)
# library(ghibli)
library(patchwork)
# library(plotly)
library(gt)
library(progress)

# Reproducibility
library(usethis)
library(here)


# Speed
# library(data.table)
library(dtplyr)
library(arrow)
library(furrr)


# Setup parallelization plan
future::plan(strategy = 'multisession', workers = 11)

# --- Setup the ggplot theme ---
source("resources/ggplot2_themes.R")
theme_set(theme_roboto())


# --- Import Aux Functions ---
source("R/rv_sparse.R")
source("R/split_intraday.R")
```

```{r}
# Read the data
ipc_intraday <- read_parquet(here("data/processed/intraday_ipc.parquet"))
```

# 1. Realized Volatility

To estimate daily volatility of equity returns, we can use the intraday data, in particular, the intraday returns. Since the expected value of the intraday returns is zero, a good estimator of variance is the sum of the squared returns.

We can now compute the realized variance for each day:

```{r}
rv_df <- ipc_intraday %>% 
  filter(!is.na(log_ret)) %>% 
  mutate(log_ret_sq = log_ret^2) %>% 
  group_by(index_date) %>% 
  summarise(RV = sum(log_ret_sq),
            
            # annualized realized volatility
            RVol = sqrt(252 * RV),
            .groups = "drop") %>% 
  
  # Get rid of date "2001-09-12", which has a 0 RV.
  filter(!RVol == 0)

rv_df
```



Now let's plot the RVs:

```{r}
#| layout: "l-body-outset"
#| fig.width: 8
#| fig.asp: 0.618

rv_plot <- rv_df %>% 
  # filter_time("1996" ~ "end") %>%
  ggplot(mapping = aes(x = index_date, y = RV)) +
  geom_col(color = blog_colors[1]) +
  labs(
    title = "Realized Variance: S&P/BMV IPC Index",
    subtitle = "– Daily Realized Variance",
    x = NULL,
    y = NULL,
    caption = "Figure 1: Daily realized variance (RV) for the S&P/BMV IPC Index.\nThe daily RV is calculated as the sum of squared intraday returns per day."
  ) +
  scale_x_date(
    date_labels = "%Y", 
    breaks = scales::breaks_pretty(n = 12),
    expand = expansion(c(0.01, 0.01))
  ) +
  scale_y_continuous(
    breaks = scales::breaks_extended(n = 8),
    labels = scales::number_format(accuracy = .0001),
    expand = expansion(c(0, 0.13))
  ) +
  theme(
    panel.grid.major.x = element_blank()
  )

rv_plot
```


Let's check the ACF on the RVs:

```{r}
#| layout: "l-body-outset"
#| fig.width: 8
#| fig.asp: 0.618


acf_plot1 <- rv_df %>% 
  pull(RV) %>% 
  acf(lag.max = 200, plot = F) %>% 
  broom::tidy() %>% 
  filter(lag != 0) %>% 
  ggplot(aes(lag, acf)) +
  geom_line(aes(color = lag >= 10), size = 1.1) +
  
  # Bartlett Errors
  geom_hline(yintercept = 2/sqrt(nrow(rv_df)), 
             linetype = 2,
             color = blog_colors[4]) +
  geom_hline(yintercept = -2/sqrt(nrow(rv_df)), 
             linetype = 2,
             color = blog_colors[4]) +
  
  
  geom_hline(yintercept = 0, linetype = 1) +
  scale_x_continuous(
    breaks = scales::breaks_pretty(n = 12),
    expand = expansion(c(0.015, 0.03))
  ) +
  scale_y_continuous(
    breaks = scales::breaks_extended(n = 8),
    labels = scales::number_format(accuracy = .01),
    expand = expansion(c(0.02, 0.13)),
    limits = c(-0.1,0.5)
  ) +
  scale_color_manual(values = blog_colors) +
  guides(color = 'none') +
  labs(
    title = "ACF of realized variance",
    subtitle = "– The x-axis indicates the k-th lag order.",
    x = NULL,
    y = NULL,
    caption = "Figure 2: the blue line indicates the first 10-lag order autocorrelations for the RVs.\nBartlett confidence intervals in dashed, purple lines."
  ) +
  theme(
    panel.grid.major.x = element_blank(),
  )
  
```

And now let's check the ACF of the daily squared returns:

```{r}
ipc_daily <- readxl::read_excel(
  path = here("data/raw/ipc_daily_close.xlsx"),
  sheet = "IPC",
  col_types = c('date', rep('numeric', 4))
  )

ipc_daily_clean1 <- ipc_daily %>% 
  mutate(date = as_date(date)) %>% 
  drop_na(date)


ipc_daily2 <- readxl::read_excel(
  path = here("data/raw/ipc_daily_close.xlsx"),
  sheet = "IPC"
  )

ipc_daily_clean2 <- ipc_daily2 %>% 
  filter(str_detect(date, "/")) %>% 
  mutate(date = mdy(date))

# Get minimum date
min_date <- rv_df %>% 
  pull(index_date) %>% 
  min()


ipc_daily_clean <- ipc_daily_clean1 %>% 
  bind_rows(ipc_daily_clean2) %>% 
  arrange(date) %>% 
  filter(date >= min_date)

ipc_daily_returns <- ipc_clean %>% 
  mutate(
    log_ret = log(close/ lag(close)),
    sq_ret = log_ret^2
    ) %>% 
  drop_na(log_ret)

acf_plot2 <- ipc_daily_returns %>% 
  pull(sq_ret) %>% 
  acf(lag.max = 200, plot = F) %>% 
  broom::tidy() %>% 
  filter(lag != 0) %>% 
  ggplot(aes(lag, acf)) +
  geom_line(aes(color = lag >= 10), size = 1.1) +
  
  # Bartlett Errors
  geom_hline(yintercept = 2/sqrt(nrow(rv_df)), 
             linetype = 2,
             color = blog_colors[4]) +
  geom_hline(yintercept = -2/sqrt(nrow(rv_df)), 
             linetype = 2,
             color = blog_colors[4]) +
  
  
  geom_hline(yintercept = 0, linetype = 1) +
  scale_x_continuous(
    breaks = scales::breaks_pretty(n = 12),
    expand = expansion(c(0.015, 0.03))
  ) +
  scale_y_continuous(
    breaks = scales::breaks_extended(n = 8),
    labels = scales::number_format(accuracy = .01),
    expand = expansion(c(0.02, 0.13)),
    limits = c(-0.1,0.5)
  ) +
  scale_color_manual(values = blog_colors) +
  guides(color = 'none') +
  labs(
    title = "ACF of daily squared returns",
    subtitle = "– The x-axis indicates the k-th lag order.",
    x = NULL,
    y = NULL,
    caption = "Figure 3: the blue line indicates the first 10-lag order autocorrelations for the \nsquared log-returns of the IPC Index. Bartlett confidence intervals in dashed, purple lines."
  ) +
  theme(
    panel.grid.major.x = element_blank(),
  )
```

```{r}
acf_plot1/acf_plot2
```



# 2. RV Sparse

An *RV Sparse* estimator consists of calculating the realized variance but with a sample that is less frequent than the 1-minute grid. Instead, it is sampled in an *s*-minute grid (where $s \geq 1$).

Here, we will use different combinations of $s$ such as `s = 5`, `s = 10`, `s = 15`, and `s = 30`. In order to plot a *signature plot*, we will also sample from $s \in [1, 120]$.


## Volatility signature plot

The Sparse RV Estimator is calculated using an *s*-minute grid ($s \geq 1$):

$$ 
RV_{t+1}^s = \sum \limits_{j=1}^{m/s} R^2_{t+js/m} 
$$


Now the problem lies in the choice of the sub-sampling parameter $s$, a problem which represents a typical bias-variance trade-off. That is because ...

This is where *volatility signature plots* (VSP) will help; these are a graphical tool that helps us choose the sub-sampling parameter $s$. We do a VSP in the following manner:

1.  Compute $RV_{t+1}^s$ for values of $s$ going from 1 to 120 minutes.

```{r}
# Define progress bar
pb <- progress::progress_bar$new(
  format = " computing RVs [:bar] :percent eta: :eta",
  total = 100,
  clear = FALSE
)

# Define a vector with all the "s-grid" parameters
sparse_grid <- seq(from = 1, 
                   to = 55, 
                   by = 5) - 1

sparse_grid[1] <- 1


# Create a tibble with all the nested data
ipc_sparse <- sparse_grid %>% 
  future_map_dfr(~ split_intraday(data = ipc_intraday, 
                                  grid = .x), # %>% 
                   # rv_sparse(),
                 .progress = T)

ipc_sparse %>% 
  filter(sparse_grid == 5)
```

```{r unnest-RV-sparse}
# Get the mean for each RV sparse:
RV_means <- ipc_sparse %>% 
  group_by(sparse_grid) %>% 
  summarise(
    mean_RV_sparse = mean(RVol_sparse),
    .groups = "drop"
  )
```

2.  Scatter plot the average RV across days on the vertical axis against $s$ on the horizontal axis.

```{r}
#| layout: "l-body-outset"
#| fig.width: 8
#| fig.asp: 0.618

RV_means %>% 
  ggplot(aes(sparse_grid , mean_RV_sparse)) +
  geom_point(colour = blog_colors[2], 
             size = 2) +
  labs(
    title = "Signature Plot for the Annualized RV Sparse",
    x = "Minutes",
    y = "RV"
  ) +
  scale_y_continuous(labels = number_format())
```

3.  Look for the smallest $s$ such that the average RV does not change much for values of $s$ larger than this number.



# HAR Model

The HAR (Heterogeneous Autoregression) model or mixed-frequency model provides a tool for modeling the seemingly long-memory features of realized volatility.

We can start by defining the _h_-day RV from the 1-day RV as follows:

$$
RV_{t-h+1,\ t} = \big(RV_{t-h+1} + RV_{t-h+2} + \ \cdots \  +RV_t\big)/h
$$