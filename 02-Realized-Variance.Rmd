---
title: "Realized Higher Moment Measures"
description: |
  Part 2: Exploring Realized Higher Moment Measures on the S&P/BMV IPC Index
author:
  - name: Alexis Solis Cancino
    affiliation: ITAM
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc: true
    toc_depth: 2
    css: "resources/theme.css"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  
  # Places figures on their own pages
  fig.pos = 'p',
  
  # Figure resolution and size
  out.width = '100%',
  dpi = 400,
  
  # Latex figure environment
  fig.env = "figure"
)


# --- Load the libraries! ---

# Data Wrangling
library(tidyverse)
library(lubridate)
library(skimr)
library(glue)

# Time Series
library(timetk)
library(tidyquant)
# library(hms)
# library(modeltime)
# library(tidymodels)

# Visualization
# library(ggthemes)
library(scales)
# library(ghibli)
library(cowplot)
# library(plotly)
library(gt)
library(progress)

# Reproducibility
library(usethis)
library(here)


# Speed
# library(data.table)
library(dtplyr)
library(arrow)
library(furrr)


# Setup parallelization plan
future::plan(strategy = multiprocess, workers = 11)

# --- Setup the ggplot theme ---
source("resources/ggplot2_themes.R")
theme_set(theme_roboto())
```

```{r}
# Read the data
ipc_intraday <- read_parquet(here("data/processed/intraday_ipc.parquet"))
```

# 1. Realized Volatility

To estimate daily volatility of equity returns, we can use the intraday data, in particular, the intraday returns. Since the expected value of the intraday returns is zero, a good estimator of variance is the sum of the squared returns.

We can now compute the realized variance for each day:

```{r}
rv_df <- ipc_intraday %>% 
  filter(!is.na(log_ret)) %>% 
  mutate(log_ret_sq = log_ret^2) %>% 
  group_by(index_date) %>% 
  summarise(RV = sum(log_ret_sq),
            
            # annualized realized volatility
            RVol = sqrt(252 * RV),
            .groups = "drop") %>% 
  
  # Get rid of date "2001-09-12", which has a 0 RV.
  filter(!RVol == 0)

rv_df
```



Now let's plot the RVs:

```{r}
#| layout: "l-body-outset"
#| fig.width: 8
#| fig.asp: 0.618

rv_plot <- rv_df %>% 
  # filter_time("1996" ~ "end") %>%
  ggplot(mapping = aes(x = index_date, y = RV)) +
  geom_col(color = blog_colors[1]) +
  labs(
    title = "Realized Variance: S&P/BMV IPC Index",
    subtitle = "– Daily Realized Variance",
    x = NULL,
    y = NULL,
    caption = "Figure 1: Daily realized variance (RV) for the S&P/BMV IPC Index.\nThe RV is calculated as the sum of squared intraday returns."
  ) +
  scale_x_date(
    date_labels = "%Y", 
    breaks = scales::breaks_pretty(n = 12),
    expand = expansion(c(0.01, 0.01))
  ) +
  scale_y_continuous(
    breaks = scales::breaks_extended(n = 8),
    labels = scales::number_format(accuracy = .0001),
    expand = expansion(c(0, 0.13))
  ) +
  theme(
    panel.grid.major.x = element_blank()
  )

rv_plot
```


Let's check the ACF on the RVs:

```{r}
#| layout: "l-body-outset"
#| fig.width: 8
#| fig.asp: 0.618


rv_df %>% 
  pull(RV) %>% 
  acf(lag.max = 100, plot = F) %>% 
  broom::tidy() %>% 
  filter(lag != 0) %>% 
  ggplot(aes(lag, acf)) +
  geom_line(aes(color = lag >= 10)) +
  geom_hline(yintercept = 0.2, linetype = 2) +
  scale_x_continuous(
    breaks = scales::breaks_pretty(n = 12),
    expand = expansion(c(0.015, 0.05))
  ) +
  scale_y_continuous(
    breaks = scales::breaks_extended(),
    labels = scales::number_format(accuracy = .01),
    expand = expansion(c(0.02, 0.13))
  ) +
  scale_color_manual(values = blog_colors) +
  guides(color = 'none') +
  labs(
    title = "Autocorrelation of realized variance",
    subtitle = "– The x-axis indicates the k-th lag order.",
    x = NULL,
    y = NULL,
    caption = "Figure 2: the blue line indicates the first 10-lag order autocorrelations for the RVs."
  ) +
  theme(
    panel.grid.major.x = element_blank(),
    
  )
  
```




# 2. RV Sparse

An *RV Sparse* estimator consists of calculating the realized variance but with a sample that is less frequent than the 1-minute grid. Instead, it is sampled in an *s*-minute grid (where $s \geq 1$).

Here, we will use different combinations of $s$ such as `s = 5`, `s = 10`, `s = 15`, and `s = 30`. In order to plot a *signature plot*, we will also sample from $s \in [1, 120]$.


## Volatility signature plot

The Sparse RV Estimator is calculated using an *s*-minute grid ($s \geq 1$):

$$ 
RV_{t+1}^s = \sum \limits_{j=1}^{m/s} R^2_{t+js/m} 
$$


Now the problem lies in the choice of the sub-sampling parameter $s$, a problem which represents a typical bias-variance trade-off. That is because ...

This is where *volatility signature plots* (VSP) will help; these are a graphical tool that helps us choose the sub-sampling parameter $s$. We do a VSP in the following manner:

1.  Compute $RV_{t+1}^s$ for values of $s$ going from 1 to 120 minutes.



```{r}
# Define progress bar
pb <- progress::progress_bar$new(
  format = " computing RVs [:bar] :percent eta: :eta",
  total = 100,
  clear = FALSE
)

# Define a vector with all the "s-grid" parameters
sparse_grid <- seq(from = 1, 
                   to = 60, 
                   by = 1)


# Create a tibble with all the nested data
ipc_sparse <- sparse_grid %>% 
  future_map_dfr(~ split_intraday(data = ipc_intraday, 
                                  grid = .x) %>% 
                   rv_sparse(),
                 .progress = T)
```

```{r unnest-RV-sparse}
# Get the mean for each RV sparse:
RV_means <- ipc_sparse %>% 
  group_by(sparse_grid) %>% 
  summarise(
    mean_RV_sparse = mean(RV_sparse),
    .groups = "drop"
  )
```

2.  Scatter plot the average RV across days on the vertical axis against $s$ on the horizontal axis.

```{r, layout="l-body-outset", fig.width=8, fig.asp=0.618}
RV_means %>% 
  ggplot(aes(sparse_grid , mean_RV_sparse)) +
  geom_point(alpha = 0.6, 
             colour = blog_colors[1], 
             size = 2) +
  labs(
    title = "Signature Plot for the Annualized RV Sparse",
    x = "Minutes",
    y = "RV"
  ) +
  scale_y_continuous(labels = number_format())
```
